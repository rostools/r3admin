---
title: "Introduction course admin tasks"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  eval = FALSE,
  collapse = TRUE,
  comment = "#>"
)
library(tidyverse)
library(ghclass)
devtools::load_all()
course_date <- "2023-01-16"
course_type <- "r-cubed"
org_gh_course_name <- "r-cubed-2023-01"

# Set GitHub PAT
gitcreds::gitcreds_set()
ghclass::github_set_token(gitcreds::gitcreds_get(use_cache = FALSE)$password)
```

# Pre-course admin tasks

```{r, eval=FALSE}
admin_create_planning_issue(course_type, course_date, host = "gitlab")
```

## Fetch (and save) pre-survey responses

First thing, need to get the precourse results.

```{r}
# TODO: How to get these authenticated? Run first and then build vignette?
googledrive::drive_auth()
googlesheets4::gs4_auth()
precourse <- fetch_precourse_intro() %>%
  filter(course_version == max(course_version))
```

## Who didn't finish survey

Check those who didn't finish the survey yet. Do need the official list
to compare with, which can be deleted after the course.

```{r, eval=FALSE}
participants <- check_who_not_finish_survey(
  precourse,
  readr::read_csv(here::here("_ignore/official-participant-list-emails-2023-01-16.csv"))
)
nrow(participants)
View(participants)
```

Then need to send a reminder email to those who didn't complete the
survey or tasks yet.

```{r, eval=FALSE}
copy_emails_for_reminder(participants)
copy_reminder_email_text()
```

## Basic setup checks

Quickly check whether everyone has their setups done correctly.

```{r, results='asis'}
cat(check_setup(precourse))
```

```{r, results='asis'}
cat(check_project_setup(precourse))
```

## Who has problems

List those who have problems and print their setups.

```{r, results='asis'}
problems <- precourse %>%
  check_precourse_problems()
```

### Description of the problems

```{r, results='asis'}
problems %>%
  check_problem_description() %>%
  cat()
```

### Setup of those with problems

```{r, results='asis'}
problems %>%
  check_setup() %>%
  cat()
```

### Copy names to address in first day

Copy the names of those who have problems so I can paste it to something
like Telegram so I know who to seek out on the first day.

```{r, eval=FALSE}
problems %>%
  dplyr::pull(full_name) %>%
  copy_names_with_problems()
```

## Create group names

Create some fun group names for the course. There is some manual action
here to select the names I think are interesting or funky. Make groups
with about 4 people per group.

```{r}
set.seed(154)
group_names <- create_group_names()

ceiling(nrow(precourse) / 4)
group_names_final <- group_names[c(10, 11, 12, 14, 19,
                                   24, 27, 32, 53, 54)]
group_names_final
```

Create PDF files of the group names, so we can print the files before
the first day and put one of them on each table.

```{r, eval=FALSE, results='hide'}
group_names_final %>%
  group_names_to_one_pdf()
```

### Assigning members to groups

Now we need to assign the learners to the groups.

```{r}
learners_in_groups <- assign_learners_to_groups(
  precourse,
  group_names_final
)
count(learners_in_groups, team)
View(learners_in_groups)

# Manually change if need be.
learners_in_groups <- edit(learners_in_groups)
```

## Creating the GitHub org and groups

Follow the instructions on the [ghclass
vignette](https://rundel.github.io/ghclass/articles/ghclass.html) First,
you need to create the organization manually. Use the value in here as
the name:

```{r}
# Name for organization.
org_gh_course_name
```

Invite participants onto GitHub:

```{r, eval=FALSE}
# org_invite(org_gh_course_name, precourse$github_username)
org_members(org_gh_course_name)
org_pending(org_gh_course_name)
```

Then we can create the teams based on the group names:

```{r}
# team_create(org_gh_course_name, group_names_final)
org_teams(org_gh_course_name)
```

Then assign the people to the teams followed by making repos for each
team.

```{r, eval=FALSE}
team_invite(
  org_gh_course_name,
  learners_in_groups$github_username,
  learners_in_groups$team
)

gh_repos <- repo_create(org_gh_course_name, group_names_final)
repo_add_team(sort(gh_repos), sort(unique(learners_in_groups$team)))
```

Make a table for the planning issue to put the instructors in groups.
There might be some manual tinkering here.

```{r}
instructors <- c(
  "Anders", "Elise", "Luke", "Anders", "Menghan", "Mudit", "NÃºria",
  "Marcus", "Samah", "Vi"
)
instructors_to_groups <- assign_instructors_to_groups(group_names_final, instructors)
```

Then take instructors and assigned teams and convert them into a
Markdown table to paste into the planning issue.

```{r, eval=FALSE}
# TODO: Convert to a function.
org_team_repos <- sort(org_repos(org_gh_course_name))
instructors_to_groups %>%
  arrange(team) %>% 
  mutate(team = glue::glue("[{team}](https://github.com/{org_team_repos})")) %>%
  rename_with(str_to_sentence) %>%
  knitr::kable() %>%
  clipr::write_clip()
```

## Invite to Slack group

```{r, eval=FALSE}
copy_emails_for_slack_invite(precourse$email)
```

## Create projects to push to repos

## Post course admin

Need to run these inside the project.

```{r, eval=FALSE}
```
